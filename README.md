# Riakuto-4ed

## Chapter1 〜 Chapter4
[りあクト！ TypeScriptで始めるつらくないReact開発 第4版【① 言語・環境編】](https://booth.pm/ja/items/2368045)

### 第 1章 こんにちはReact
#### 1-1.　基本環境の構築
    1-1-1.　Node.js がなぜフロントエンド開発に必要なのか
    1-1-2.　Node.js をインストールする
    1-1-3.　超絶推奨エディタ Visual Studio Code
#### 1-2.　Vite でプロジェクトを作成する
#### 1-3.　プロジェクトを管理するためのコマンドやスクリプト
    1-3-1.　Yarn
    1-3-2.　npm スクリプト

### 第 2章 ライトでディープなJavaScriptの世界
#### 2-1.　あらためて JavaScript ってどんな言語？
    2-1-1.　それは世界でもっとも誤解されたプログラミング言語
    2-1-2.　年々進化していく JavaScript
#### 2-2.　変数の宣言
#### 2-3.　JavaScript のデータ型
    2-3-1.　JavaScript におけるプリミティブ型
    2-3-2.　プリミティブ値のリテラルとラッパーオブジェクト
    2-3-3.　オブジェクト型とそのリテラル
#### 2-4.　関数の定義
    2-4-1.　関数宣言と関数式
    2-4-2.　アロー関数式と無名関数
    2-4-3.　さまざまな引数の表現
#### 2-5.　クラスを表現する
    2-5-1.　クラスのようでクラスでない、JavaScript のクラス構文
    2-5-2.　プロトタイプベースのオブジェクト指向とは
#### 2-6.　配列やオブジェクトの便利な構文
    2-6-1.　分割代入とスプレッド構文
    2-6-2.　オブジェクトのマージとコピー
#### 2-7.　式と演算子で短く書く
    2-7-1.　ショートサーキット評価
    2-7-2.　Nullish Coalescing と Optional Chaining
#### 2-8.　JavaScript の鬼門、this を理解する
    2-8-1.　JavaScript の this とは何なのか
    2-8-2.　this の中身 4 つのパターン
    2-8-3.　this の挙動の問題点と対処法
#### 2-9.　モジュールを読み込む
    2-9-1.　JavaScript モジュール三國志
    2-9-2.　ES Modules でインポート／エクスポート

### 第 3章 関数型プログラミングでいこう
#### 3-1.　関数型プログラミングは何がうれしい？
#### 3-2.　コレクションの反復処理
    3-2-1.　配列の反復処理
    3-2-2.　オブジェクトの反復処理
#### 3-3.　JavaScript で本格関数型プログラミング
    3-3-1.　あらためて関数型プログラミングとは何か
    3-3-2.　高階関数
    3-3-3.　カリー化と関数の部分適用
    3-3-4.　閉じ込められたクロージャの秘密
#### 3-4.　非同期処理と例外処理
    3-4-1.　Promise で非同期処理を扱う
    3-4-2.　async と await
    3-4-3.　JavaScript の例外処理

### 第 4章 TypeScript で型をご安全に
#### 4-1.　ナウなヤングに人気の TypeScript
#### 4-2.　TypeScript の基本的な型
    4-2-1.　型アノテーションと型推論
    4-2-2.　JavaScript と共通のデータ型
    4-2-3.　Enum 型とリテラル型
    4-2-4.　タプル型
    4-2-5.　any、unknown、never
#### 4-3.　関数とクラスの型
    4-3-1.　関数の型定義
    4-3-2.　TypeScript でのクラスの扱い
    4-3-3.　クラスの 2 つの顔
#### 4-4.　型の名前と型合成
    4-4-1.　型エイリアス VS インターフェース
    4-4-2.　ユニオン型とインターセクション型
    4-4-3.　型の Null 安全性を保証する
#### 4-5.　さらに高度な型表現
    4-5-1.　型表現に使われる演算子
    4-5-2.　条件付き型とテンプレートリテラル型
    4-5-3.　組み込みユーティリティ型
    4-5-4.　関数のオーバーロード
#### 4-6.　型アサーションと型ガード
    4-6-1.　as による型アサーション
    4-6-2.　型ガードでスマートに型安全を保証する
#### 4-7.　モジュールと型定義
    4-7-1.　TypeScript のインポート／エクスポート
    4-7-2.　JavaScript モジュールを TypeScript から読み込む
    4-7-3.　モジュールの型はどのように解決されるか
#### 4-8.　TypeScript の環境設定
    4-8-1.　コンパイラオプション strict
    4-8-2.　tsconfig.json の設定項目
    4-8-3.　複数の tsconfig.json を連携させる

## Chapter5 〜 Chapter9
[りあクト！ TypeScriptで始めるつらくないReact開発 第4版【② React基礎編】](https://booth.pm/ja/items/2368019)

### 第5章　JSX で UI を表現する
#### 5-1.　なぜ React では JSX を使うのか
    5-1-1.　JSX はどのように変換されるか
    5-1-2.　なぜ React ではデザインとロジックを混在させるのか
    5-1-3.　なぜ React はテンプレートを使わないのか
    5-1-4.　JSX は汎用的に UI を表現する
#### 5-2.　JSX 構文の書き方
    5-2-1.　JSX の基本的な文法
    5-2-2.　JSX とコンポーネントの関係
    5-2-3.　React の組み込みコンポーネント

### 第6章　進化したビルドツールを活用する
#### 6-1.　コンパイラとモジュールバンドラ
    6-1.1.　フロントエンド開発に使われるコンパイラ
    6-1-2.　モジュールバンドラの登場
    6-1-3.　新しい波を生んだ次世代モジュールバンドラ
#### 6-2.　Vite Killied the Other Star
    6-2-1.　ノーバンドルなビルドツール Snowpack
    6-2-2.　Create React App はもう古い？
    6-3-3.　絶賛ブレイク中の Vite
#### 6-3.　Vite を本格的に使いこなす
#### 6-4.　Deno が JavaScript の世界を塗り替える？
    6-4-1.　Deno とは何か
    6-4-2.　Deno の特徴
    6-4-3.　Node.js との互換性
    6-4-4.　Deno はもう実用に耐えうるか

### 第7章　リンターとフォーマッタでコード美人に
#### 7-1.　リンターでコードの書き方を矯正する
    7-1-1.　JavaScript、TypeScript におけるリンターの歴史
    7-1-2.　ESLint の環境を作る
    7-1-2.　ESLint の環境をカスタマイズする
#### 7-2.　フォーマッタでコードを一律に整形する
    7-2-1.　コードフォーマッタの地位を確立した Prettier
    7-2-2.　Prettier の環境を作る
#### 7-3.　スタイルシートもリンティングする
#### 7-4.　さらに進んだ設定

### 第8章　React をめぐるフロントエンドの歴史
#### 8-1.　React の登場に至る物語
    8-1-1.　すべては Google マップショックから始まった
    8-1-2.　フロントエンド第 2 世代技術の興隆
    8-1-3.　Web Components が夢見たもの
    8-1-4.　そして React が誕生する
#### 8-2.　React を読み解く 6 つのキーワード
    8-2-1.　公式サイトトップに掲げられている三大コンセプト
    8-2-2.　Declarative
    8-2-3.　Component-Based、Just The UI
    8-2-4.　Virtual DOM
    8-2-5.　One-Way Dataflow
    8-2-6.　Learn Once, Write Anywhere
#### 8-3.　他のフレームワークとの比較
    8-3-1.　第 3 世代のフレームワーク情勢
    8-3-2.　Lit
    8-3-3.　Svelte
    8-3-4.　Preact
    8-3-5.　Solid

### 第9章　コンポーネントの基本を学ぶ
#### 9-1.　コンポーネントのメンタルモデル
#### 9-2.　コンポーネントに Props を受け渡す
#### 9-3.　コンポーネントに State を持たせる
#### 9-4.　コンポーネントと副作用
#### 9-5.　クラスでコンポーネントを表現する

## Chapter10 〜　Chapter15
[りあクト！ TypeScriptで始めるつらくないReact開発 第4版【③ React応用編】](https://booth.pm/ja/items/2367992)

### 第10章　コンポーネント操作の高度な技法
#### 10-1.　ロジックを分離、再利用する技術
    10-1-1.　React におけるロジック分離技術の歴史
    10-1-2.　コミュニティ主導で普及した HOC
    10-1-3.　HOC の対抗馬 Render Props
    10-1-4.　ついに Hooks へと至る
    10-1-5.　Custom Hook でロジックを再利用しやすくする
#### 10-2.　フォームをハンドリングする
    10-2-1.　素の React でフォームを扱うには
    10-2-2.　フォームヘルパーはどれ使うべきか
    10-2-3.　React Hook Form を使う
    10-2-4.　Yup でスキーマバリデーション
#### 10-3.　コンポーネントのレンダリングを最適化する
    10-3-1.　コンポーネントのライフサイクル
    10-3-2.　メモ化で計算リソースを節約する
    10-3-3.　メモ化で不要な再レンダリングを防ぐ
    10-3-4.　優先度の低いレンダリングを遅延させる

### 第11章　React アプリケーションの開発手法
#### 11-1.　React アプリケーションのデバッグ
    11-1-1.　コンソールにデータをダンプする
    11-1-2.　React Developer Tools を使いこなす
#### 11-2.　コンポーネントの設計
    11-2-1.　命名規則を遵守する
    11-2-2.　SOLID の原則
    11-2-3.　Presentational Component と Container Component
    11-2-4.　Atomic Design
#### 11-3.　プロジェクトのディレクトリ構成

### 第12章　React のページをルーティングする
#### 12-1.　ルーティングについて知ろう
    12-1-1.　SPA におけるルーティングとは
    12-1-2.　ルーティングライブラリの選定
    12-1-3.　ファイルシステムベースのルーティング
#### 12-2.　React Router の基本的な使い方
    12-2.1.　React Router を導入する
    12-2.2.　React Router のコンポーネント API
    12-2.3. React Router の Hooks API
#### 12-3.　React Router をアプリケーションで使う

### 第13章　Redux でグローバルな状態を扱う
#### 13-1.　Redux をめぐる状態管理の歴史
    13-1-1.　Redux 以前の模索の時代
    13-1-2.　そして Redux が登場した
#### 13-2.　Redux の使い方
    13-2-1.　Redux の思想を理解する
    13-2-2.　Redux をアプリケーションに組み込む
    13-2-3.　Redux 公式スタイルガイド
#### 13-3.　Redux Toolkit を使って楽をしよう
#### 13-4.　useReducer はローカルに使える Redux
    13-4-1.　useReducer で Redux の処理を書き直す
    13-4-2.　useReducer と State Hook の正体

###　第14章　ポスト Redux 時代の状態管理
#### 14-1.　Context API の登場
#### 14-2.　React で非同期処理とどう戦うか
    14-2-1. コンポーネントの中で非同期処理を行う
    14-2-2.　Redux ミドルウェアの黄金時代
    14-2-3.　Redux ミドルウェアは非同期処理の課題を解決できたのか
    14-2-4.　公式が示した Effect Hook という道
#### 14-3.　Redux オルタナティブな状態管理ライブラリ
#### 14-4.　Redux はもう不要なのか？
    14-4.1.　Redux と React の間の距離感の変遷
    14-4-2.　Redux 周辺を取り巻くトレンドの変化
    14-4-3.　この先 Redux とどうつきあっていくべきか

### 第15章　React 18 の新機能を使いこなす
#### 15-1.　React 18 はなぜ特別なバージョンなのか
    15-1-1.　皆が待ち望んでいた？React 18
    15-1-2.　公式が React 18 をどうしても出したかった理由
#### 15-2.　React 18 の新機能を有効にする
    15-2-1.　新しいルート API
    15-2-2.　Strict モード
#### 15-3.　Concurrent Rendering の具体的なメリット
    15-3-1.　State 更新の自動バッチ処理
    15-3-2.　レンダリングをサスペンドする
    15-3-3.　緊急性を考慮してレンダリングさせる
#### 15-4.　Concurrent Rendering で UI の質を高める
    15-4-1.　Suspense の優位性
    15-4-2.　Suspense に対応したデータ取得ライブラリ
    15-4-3.　SWR の使い方
    15-4-4.　Concurrent UI パターンをアプリケーションに適用する
